/*{
    "author": "Timothy Wood",
    "targets": ["omnigraffle"],
    "type": "action",
    "identifier": "art.tjw.Circle Divider",
    "version": "0.1",
    "description": "A plug-in that generates a circle with even marks for prime number angle division.",
    "label": "Circle Divider",
    "mediumLabel": "Circle Divider",
    "longLabel": "Circle Divider",
    "paletteLabel": "Circle Divider",
}*/
(() => {
    
    var action = new PlugIn.Action(function(selection) {
        // Canvas units are in points
        function inchesToCanvas(inches) {
            return inches * 72.0;   
        };
        
        console.clear();
        console.log("Running");
        
        const canvas = selection.canvas;
        
        const innerDiameter = inchesToCanvas(12);
        const outerDiameter = inchesToCanvas(18);
        const slotWidth = inchesToCanvas(1/8);
        const slotInset = inchesToCanvas(3/8);
        
        const cut = Color.RGB(0, 0, 1);
        const engraveLine = Color.RGB(1, 0, 0);
        const engraveArea = Color.RGB(0, 0, 0);
        
        // Inner and outer circle cuts
        var inner = canvas.addShape("Circle", new Rect(-innerDiameter/2, -innerDiameter/2, innerDiameter, innerDiameter));
        inner.strokeColor = cut;
        inner.fillColor = null;
        inner.shadowColor = null;
        inner.name = "Inner";
        
        var outer = canvas.addShape("Circle", new Rect(-outerDiameter/2, -outerDiameter/2, outerDiameter, outerDiameter));
        outer.strokeColor = cut;
        outer.fillColor = null;
        outer.shadowColor = null;
        outer.name = "Outer";
        
        var slotGroups = [];
        
        function degreesToRadians(degrees){
            return (degrees / 360) * (2 * Math.PI);
        };
        
        function angleDifference(a, b){
            // There is no Math.fmod.
            var diff = a - b;
            while (diff < 0) {
                diff += 360;
            }
            return diff;
        };
        
        function makeSlotsGroup(canvas, slots, startAngle, endAngle){
            // For now, just add lines to show the split between groups
            var radius = outerDiameter;

            var radians = degreesToRadians(startAngle);            
            canvas.addLine(Point.zero, new Point(Math.cos(radians) * radius, Math.sin(radians) * radius));
            
            radians = degreesToRadians(endAngle);
            canvas.addLine(Point.zero, new Point(Math.cos(radians) * radius, Math.sin(radians) * radius));
        };
        
        function splitSlotsIntoGroups(canvas, slots) {
            // Sweep through the sorted slots and divide into groups of approximately 1/8th the circle.
            // TODO: Back track or otherwise adjust the groups in cases where the dividing point would be on two slots that are very close (like with the 13 and 17).
        
            slots.forEach(function(slot){
                console.log("slot", slot.rotation, slot.name);
            });
        
            // The first slot should be at rotation == 0 and the last the highest. Start our sweep halfway between the last slot and the first (which is also at 360 degrees)
            var firstSweepAngle = (slots[slots.length - 1].rotation + 360)/2;
            var groupStartAngle = firstSweepAngle;
            var currentSweepAngle = firstSweepAngle;
            console.log("currentSweepAngle", currentSweepAngle);

            var group = [];
            
            console.log("slots.length", slots.length);
            
            while (slots.length > 0) {
                console.log("slots.length", slots.length);
                if (slots.length == 1) {
                    console.log("last slot");
                    // Last slot, the end of its group should be the same as the start of the first group
                    currentSweepAngle = firstSweepAngle;
                    group.push(slots.shift());
                    makeSlotsGroup(canvas, group, groupStartAngle, firstSweepAngle);
                } else {
                    // The candidate next angle, midway between the next two slots
                    var slot0 = slots[0];
                    var slot1 = slots[1];
                    var candidateAngle = (slot0.rotation + slot1.rotation) / 2;
                    
                    var groupAngle = angleDifference(candidateAngle, groupStartAngle);
                    console.log("groupAngle", groupAngle, candidateAngle, groupStartAngle);

                    if (groupAngle > 360/8) {
                        console.log("split group", candidateAngle);
                        
                        // Too much, make a new group
                        makeSlotsGroup(canvas, group, groupStartAngle, currentSweepAngle);
                        groupStartAngle = currentSweepAngle;
                        currentSweepAngle = candidateAngle;
                        group = [slot0];
                        slots.shift();
                    } else {
                        console.log("continue group", candidateAngle);

                        // Continue the existing group
                        group.push(slots.shift());
                        currentSweepAngle = candidateAngle;
                    }
                }
            }
            
            if (group.length > 0) {
                console.log("TODO: Handle last group");
            }
        };
    
        function makeSlot(canvas, label, angle){
            // OG #2934784: Performing a Union with a circle exactly center line aligned on an edge of a rectangle produces incorrect results. Make the rect ever so slightly bigger to avoid whatever numerical accuracy issue causes this.
            var fudge = inchesToCanvas(0.01);
            
            // Left is centered on the origin
            var slotLength = outerDiameter/2 - innerDiameter/2 - 2*slotInset - slotWidth;
            var left = canvas.addShape("Circle", new Rect(-slotWidth/2, -slotWidth/2, slotWidth, slotWidth));
            var mid = canvas.addShape("Rectangle", new Rect(-fudge, -slotWidth/2, slotLength + 2*fudge, slotWidth));
            var right = canvas.addShape("Circle", new Rect(slotLength - slotWidth/2, -slotWidth/2, slotWidth, slotWidth));
  
            
            var shape = canvas.combine([left, mid, right], ShapeCombination.Union);
            shape.strokeColor = cut;
            shape.fillColor = null;
            shape.shadowColor = null;
            shape.name = "Slot";
            
            var text = canvas.addText(label, new Point(slotLength + slotWidth + inchesToCanvas(1/8), 0));
            text.fillType = null;
            text.rotation = 90;
            text.fontName = "Menlo-Regular";
            text.textSize = 12;
            text.textHorizontalAlignment = HorizontalTextAlignment.Center; // The default, but be clear about it
            
            // Reset the text bounds so that it is centered on the slot, since the following movement assumes the group as a whole has the slot centered (and it looks better)
            var textBounds = text.geometry;
            textBounds.y = -textBounds.height/2;
            text.geometry = textBounds;

            
            var group = new Group([shape, text]);
            
            // Rotation is about the center of the shape. Move the center where we want it (-ish, real transforms about the origin would be better).
            // Positive angles go clockwise around the origin.
            var bounds = group.geometry;
            
            var radians = degreesToRadians(angle);
            var radius = (outerDiameter + innerDiameter) / 4 + text.geometry.height / 2;
            var center = new Point(Math.cos(radians) * radius, Math.sin(radians) * radius);
                        
            group.geometry = new Rect(center.x - bounds.width/2, center.y - bounds.height/2, bounds.width, bounds.height);
            group.rotation = angle;
            group.name = label + "-" + angle.toString();
            
            slotGroups.push(group);
            
            return group;
        };
        
        function makeSlots(canvas, label, divisor) {
            for (var step = 1; step < divisor; step += 1) {
                var angle = (360/divisor) * step;
                makeSlot(canvas, label, angle);
            }
        };
        
        // The "origin" slot that is a part of all the prime groups
        makeSlot(canvas, "â—†", 0);
        
        // Make a bunch of slots for even numbers
        makeSlots(canvas, "2", 8);
        
        for (divisor of [3, 5, 7, 11, 13, 17]) {
            makeSlots(canvas, divisor.toString(), divisor);
        }
        
        // Sort the resulting slots by their rotation so that we can form them into nearby groups for subdividing the circle for cutting.
        slotGroups.sort(function(a,b){
            return a.rotation - b.rotation;
        });
        
        splitSlotsIntoGroups(canvas, slotGroups);
    });

    action.validate = function(selection){
        return selection.canvas != null;
    };
        
    return action;
})();
